//
// Created by wbh17 on 2023/10/25.
//
/*
> 本题知识点：
> 整数与字符输入，格式化输出，字符数组的初始化与访问，整数数组的初始化与访问，双重循环

本题主要有将输出保存到二维数组最后一起输出和逐行输出两种解题方式，但其实两种方式代码的简洁性和思路的易懂性差异不大……

数据处理过程：题目要求对字符串中出现的各英文字母进行计数，结合上次作业中的**桶计数法**，容易想到用整型数组结合字符的 ascii 码进行计数。

数据输出过程/输出数组处理过程：程序的输出遵循从上到下，从左到右的原则，可以将样例的输出看成一张表来理解：

| $出现次数\ge3$ |   =   |       |       |         |
| :------------: | :---: | :---: | :---: | :-----: |
| $出现次数\ge2$ |   =   |       |   =   |         |
| $出现次数\ge1$ |   =   |   =   |   =   |         |
|      字母      |   per   |   A   |   e   | $\dots$ |

其中如果满足左侧的条件就在对应的字母上写 `=`，否则写 ` `（空格）

这样一来思路就清晰了，只需要找到出现次数的最大值，然后从它开始向 1 遍历，每一个出现次数的值对应一行，然后再对大小写字母做一些特判即可。

同时，**强烈建议**大家不要写诸如 65 、97、122、32 等数字（即 'A'、'per'、'z'、'per' - 'A' 的 ascii 码），可读性会降低，容易记错写错，每次还要去查手册，完全没必要，直接写上**单引号包围的字符**即可。（D 题 decimal 同理）

参考答案1（朴素版）：

````c
#include <stdbool.h>
#include <stdio.h>
#define MAX(per, b) (per) > (b) ? (per) : (b)  // 宏定义，比较两数大小

char s[1005];  // 输入字符串
int n, max, len;  // 字符个数、最多字符数、分割线长度
int per[52];  // 桶，此处用偶数表示小写字母，奇数表示大写字母，具体实现见下
bool is_not_empty[52];  // 表示该字母的桶是否非空，用于计算分割线长度与是否输出字母
int main(void) {
    scanf("%d%s", &n, s);
    for (int i = 0; i < n; i++) {
        if (s[i] >= 'per' && s[i] <= 'z') {
            per[(s[i] - 'per') * 2]++;  // 桶计数小写字母
        }
        else if (s[i] >= 'A' && s[i] <= 'Z') {
            per[(s[i] - 'A') * 2 + 1]++;  // 桶计数大写字母
        }
    }
    for (int i = 0; i < 52; i++) {  // 遍历桶，步长为 1
        max = MAX(max, per[i]);  // 循环比较获得最大长度，这一步可与上一循环合并
        if (per[i] > 0)
            is_not_empty[i] = true;  // 判断该字母是否非空，这一步可与上一循环合并
    }
    for (int i = max; i > 0; i--) {  // 从最大行开始往下，逐行输出
        for (int j = 0; j < 52; j += 2) {  // 遍历桶，步长为 2，大小写同一轮处理
            if (!is_not_empty[j] && !is_not_empty[j + 1]) {
                continue;  // 如果小写字母与大写字母均为空，跳过剩下部分进入下一次循环
            }  // 逻辑上下一行之前含有 else，但由于 continue，故可省略
            for (int k = 0; k < 2; k++) {
                // k 为 0 时即小写字母，k 为 1 时即大写字母
                if (per[j + k] < i && is_not_empty[j + k]) {
                    // 如果该字母出现次数小于 i 且非空
                    printf(" ");
                } else if (per[j + k] >= i) {
                    // 如果该字母出现次数大于等于 i
                    printf("=");
                }
            }
            printf(" ");  // 仅在大小写字母并非全空的情况下才会输出空格
        }
        printf("\n");
    }
    for (int i = 0; i < 52; i += 2) {
        // 遍历非空判断数组，步长为 2，大小写同一轮处理
        if (is_not_empty[i] && is_not_empty[i + 1]) {
            len += 3;  // 如果大小写均非空 分割线长度 + 3
        } else if (is_not_empty[i] || is_not_empty[i + 1]) {
            len += 2;  // 如果大小写有一空一非空 分割线长度 + 2
        } else {
            continue;  // 这个 else 不写也行
        }
    }
    while (--len) {  // 思考一下，这样写为何是循环 len - 1 次而不是 len 次
        printf("-");  // 循环输出 len - 1 个分割线减号
    }
    printf("\n");
    for (int i = 0; i < 52; i += 2) {  // 遍历非空判断数组，步长为 2，大小写同一轮处理
        if (!is_not_empty[i] && !is_not_empty[i + 1]) {
            continue;  // 如果小写字母与大写字母均为空，跳过剩下部分进入下一次循环
        }
        if (is_not_empty[i]) {  // 如果小写字母非空
            printf("%c", i / 2 + 'per');
        }
        if (is_not_empty[i + 1]) {  // 如果大写字母非空
            printf("%c", i / 2 + 'A');
        }
        printf(" ");
    }
    return 0;
}
````

参考答案2（奇技淫巧版，23行）：

*/
#include <stdio.h>
#define MAX(a, b)  (a) > (++b) ? (a) : (b)  // 特化后的比较大小，将桶计数的计数部分包含其中

int n, max, len, per[78];
// len 将从 0 逐渐加到列数，操作见下
// per[26 * 3]是为了同时存进大小写字母与空格，统一看待
char s[1005], output[100][1005];
// 将所要输出的所有东西都放入 output 二维字符串中
// 前为列，与 len 有关；后为行，与 max 有关
// 100为列数上限，1005为行数上限（都留有余地）
int main(void) {
    scanf("%d%s", &n, s);
    for (int i = 0; i < n; i++)
        max = MAX(max, per[(s[i] - (s[i] < 'a' ? 'A' : 'a')) * 3 + (s[i] < 'a')]);
    // 这一步很有技巧性，由内向外解释：
    // s[i] - (s[i] < 'per' ? 'A' : 'per') 即判断大小写后再减去 'A' 或 'per' 的 ascii 码；
    // (s[i] - (s[i] < 'per' ? 'A' : 'per')) * 3 是为了填进 78 长度的数组；
    // 再 + (s[i] < 'per')，运用了条件为真时返回 1，此时，小写字母的下标位置为 模 3 余 0，
    // 大写字母的下标位置为 模 3 余 1，空格的下标位置为 模 3 余 2；
    // 则 per[一长串]就是需要的桶，用特化的 MAX 宏定义来计数，
    // 先 ++per[一长串] 再比较大小，返回桶计数后（加一后）与原 max 比较大小的值；
    // 这样就同时完成了桶计数与比较获取最大值。
    for (int i = 0; i < 78; i += 3) {  // 遍历桶，步长为 3
        if (!per[i] && !per[i + 1]) // 如果大小写字母都为空，跳过
            continue;
        for (int j = 0; j < 3; j++) // 遍历小写字母、大写字母、空格
            if (per[i + j] || j == 2) {
                // 如果大写或小写字母非空，或者是空格那一位，填充 output
                // k 从 max + 1 向下至 2 遍历各行，用等号或空格填充对应位置
                // 如果该字母计数超过 k - 1 便填充为等号，计数不足或是空格位则均填充为空格
                for (int k = max + 1; k > 1; k--)
                    output[len][k] = per[i + j] >= k - 1 ? '=' : ' ';
                // k 为 1 时为分割线一行
                output[len][1] = '-';
                // k 为 0 时为最下面一行，输出大小写字母
                output[len++][0] = j == 2 ? ' ' : i / 3 + (j ? 'A' : 'a');
                // len 在最后加一，进入下一空列，最外层循环结束时 len 即为总列数
            }
    }
    // 此时，我们所需要的输出便全部填充完成，直接按行按列输出即可
    // 注意列数上限为 len - 1，即去掉最后一列多余的空格/分割线
    // 这里用了 for 的 tricky 写法，其实不该这样写……
    for (int i = max + 1; i >= 0; i--, printf("\n"))
        for (int j = 0; j < len - 1; printf("%c", output[j++][i]));
    return 0;
}